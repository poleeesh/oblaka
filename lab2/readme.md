# Лабораторная 2

Допустим у нас есть убунта, и есть python-файл с набором тестов, он создаёт и удаляет пользователей, проверяет их права доступа и в конце выдаёт нам результаты в виде различных графиков. И у нас есть 2 докерфайла которые создают контейнер с данным набором тестов и запускают его. Чем же плохой отличается от хорошего? Все различия разделены по командам докерфайла

## 1) FROM
В плохом файле кажется, что с этой строкой проблем нет, у нас тут и версия написана, и не просто питон, а питон с альпиной, который весит меньше всего из всех питон-докер-образов, везде же пишут по возможности использовать именно альпину для легковесности. Однако именно у питон-проектов альпину как раз таки лучше НЕ использовать, так как это может увеличить и время сборки, и сам образ. Основная причина этого кроется в том, что альпина не умеет устанавливать wheel-образы пакетов (уже скомпилированные пайтон пакеты из C), которые используются в основном сейчас, она устанавливает исходный архив пакета и сама его компилирует, что будет достаточно дольше по времени и больше по пространству.

## 2) ПОРЯДОК КОМАНД
Лучше соблюдать определённый порядок команд, так как докер-образ состоит из слоёв, и если у плохого файла что-то поменяется в тестах, то с ними придётся и переустанавливать все необходимые библиотеки. Поэтому сперва устанавливаем зависимости, устанавливаем библиотеки из requirements.txt, а потом копируем локальные файлы. 

## 3) ADD
3.1 ADD и COPY это разные команды, если вторая просто копирует файлы и ничего с ними не делает, ADD может ещё с ними химичить (например, распаковывать архивы), поэтому если цель - просто скопировать файлы, то используем просто COPY.

3.2 Командой ADD в плохом файле мы переместили весь проект в контейнер, а нам нужен только набор тестов для пользователей, поэтому всегда лучше прописывать что именно мы копируем чтобы не засорять образ

## 4) WORKDIR
Для обозначения директории, где все команды из докерфайла будут происходить, лучше всего использовать эту команду, так и легче будет разобраться человеку, наткнувшемуся на докерфайл, и не надо будет постоянно использовать cd или указывать её в командах другими способами.

## 5) RUN
5.1 В плохом докерфайле отдельно обновляется apt-get и отдельно устанавливаются зависимости. Во-первых, это плохо с точки зрения слоёв, так как тем больше слоёв тем будет дольше собираться образ, во-вторых команда update может быть закеширована образом и не запускаться перед установкой зависимостей, так что лучше их поместить в одну строку

5.2 Пакетный менеджер может оставлять кеш, который скорее всего нам не понадобится, так что его лучше удалить командой `rm -rf /var/lib/apt/lists/*` ТАМ ЖЕ где и устанавливаются пакеты, иначе кеш будет очищаться в одном слое, а обновление оставаться в другом

5.3 Ключ -y для install автоматически скажет да всем вопросам об установке пакетов, а ключ --no-install-recommends не будет устанавливать автоматически рекомендуемые пакеты.

## 6) CMD
Команда RUN выполняется при сборке образа, a CMD - при запуске контейнера. Мы хотим посмотреть, какие логи будет выдавать тест и как он вообще выполнится, так что конечно тест мы будем запускать с помощью CMD, а при RUN команда может быть закеширована и не запущена.


## Как не работать с контейнерами

1) Данные в контейнере удаляются вместе с контейнером, они не постоянны, а для нашего кейса будет лучше, если мы сохраним все результаты и графики пройденных тестов. Поэтому если хотим что-то сохранить, не оставляем это в работающем контейнере, а монтируем том, и тогда запускаем наш образ примерно так `docker run -it --mount source=vol1,target=/test/result user_tests`

2) Не использовать docker exec - какой-то главный процесс в контейнере уже выполняется, тогда зачем в нём запускать ещё один? Эта команда полезна для начала новой сессии в контейнере, в нашем случае с помощью неё можно просматривать действия теста (например, глянуть каких пользователей тест создал), но в целом это может только помешать выполнению главного процесса контейнера
